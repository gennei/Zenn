---
title: "Feature Toggle は捨てることから考えて導入しよう"
emoji: "⚙️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["FeatureToggle"]
published: true
---

## Feature Toggle は捨てることから考えて導入しよう

Feature Toggle（フラグ）、便利ですよね。

- 新機能をちょっとずつリリースしたい  
- 一部ユーザーだけに新しい挙動を試したい  
- 問題が起きたらすぐ元に戻したい  

みたいなとき、「フラグひとつで挙動が変えられる」というのは心強いです。

ただ使い方を間違えると、リリースが終わり Feature Toggle を削除するときにとても大変な目に遭います。

この記事では、読書管理アプリの「おすすめ本レコメンド」を題材に、Feature Toggle を削除しやすくするにはどのように使うといいか考えてみます。

## 例: 読書管理アプリの「おすすめ本」を賢くしたい

題材として読書管理アプリを作っているとします。  
ホーム画面には「あなたへのおすすめ本」が並んでいて、今はこんなシンプルな仕様だとしましょう。

- 最近追加した本を出しているだけ  
- もしくは積読期間が長い本を適当に並べている

ここに、新しいレコメンド機能を入れたくなります。

- 過去に読んだ本のジャンル  
- 好きな著者  
- 自分で付けた評価  

などの情報を使っておすすめする本を入れ替える機能を追加しようとしましょう。

いきなり全ユーザーを新ロジックに切り替えるのは怖いので、たとえばこんなステップを踏みたくなります。

1. まずは社内ユーザーだけ新ロジックにする  
2. 問題なさそうなら全ユーザーを新ロジックにする  

## よくある実装：コントローラで Feature Toggle による if 分岐

まずは「ついやりがち」な実装から。

```php
class HomeController
{
    public function __construct(
        private readonly LatestBookService $latestBookService,
        private readonly RecommendationService $recommendationService,
    ) {}

    public function index(): Response
    {
        $user = auth()->user();

        if (FeatureToggle::enabled('new_recommendation')) {
            // 新しいおすすめロジック
            $recommendedBooks = $this->recommendationService
                ->recommendByPersonalizedLogic($user);
        } else {
            // 旧ロジック：最近追加した本をおすすめとして出す
            $recommendedBooks = $this->latestBookService
                ->findRecentlyAdded($user, limit: 20);
        }

        return view('home.index', [
            'recommendedBooks' => $recommendedBooks,
        ]);
    }
}
```

ぱっと見は問題なさそうですよね。

- トグル ON → 新レコメンド  
- トグル OFF → これまでどおり「最近追加した本」

しかし、アプリケーションコードのど真ん中で条件分岐を書いてしまうと、時間が経つほどじわじわ効いてきます。

## 問題1：トグルを捨てるとき、また「機能開発」みたいな作業になる

Feature Toggle は本来「一時的なもの」です。  
新レコメンドが安定してもう戻さないと決めたら、不要な分岐はなくしたいのでトグルを削除したいです。

ところが、さきほどの実装だと、トグルを消すタイミングで必ずコードを触ることになります。

```php
if (FeatureToggle::enabled('new_recommendation')) {
    $recommendedBooks = $this->recommendationService
        ->recommendByPersonalizedLogic($user);
} else {
    $recommendedBooks = $this->latestBookService
        ->findRecentlyAdded($user, limit: 20);
}
```

これを手で書き換えて、最終的には

```php
$recommendedBooks = $this->recommendationService
    ->recommendByPersonalizedLogic($user);
```

だけにしたいわけですよね。

そうすると以下のような作業が発生します。
- コード修正して 
- テストも直して／追加して  
- レビューして  
- デプロイする  

という、修正する箇所がとても多いです。 「トグルを消すだけなのに本当に問題がないのかな…」という気持ちになります。

## 問題2：トグルが散らばると「今の挙動」がわかりにくくなる

もうひとつ、地味に効いてくるのがこれです。

「おすすめ本」機能がこのControllerにだけあればいいのですが、

- ホーム画面  
- メールで送る「今週のおすすめ本」  
- モバイルアプリ向け API  

など、いろんなところで同じ「おすすめ」を出したくなります。

そのたびに

```php
if (FeatureToggle::enabled('new_recommendation')) {
    // 新ロジック
} else {
    // 旧ロジック
}
```

を書くようになると、

- この画面はもう新ロジックなのか？  
- この API はまだ旧ロジックで動いているのか？  
- 他の場所と条件分岐の処理が同じなのか

というのが、コードをぜんぶ追わないと分からなくなります。

同じトグルによる分岐が増えれば増えるほどだんだん怖くて触れなくなります。また削除するときに削除漏れが発生して古い挙動に戻ってしまうこともあります。

## 対応方法：レコメンドという「振る舞い」ごと差し替える

ここで考え方を変えます。

Feature Toggle で「この行を実行するかどうか」を切り替えるのではなく、「どの振る舞い（実装）を使うか」を切り替えるという設計にしてみます。

今回の例でいえば、コントローラの中で「旧 or 新」を if で分岐するのではなく、「どのレコメンドエンジンを使うか」を差し替えるようにします。

## RecommendationEngine インターフェースを切り出す

まず、「ユーザーにおすすめ本を返す役割」をインターフェースにします。

```php
interface RecommendationEngine
{
    /**
     * @return Book[]
     */
    public function recommendFor(User $user, int $limit = 20): array;
}
```

### 旧ロジック：最近追加した本を返すエンジン

```php
class RecentBooksRecommendationEngine implements RecommendationEngine
{
    public function __construct(
        private readonly LatestBookService $latestBookService,
    ) {}

    public function recommendFor(User $user, int $limit = 20): array
    {
        // とりあえず「最近追加された本」をおすすめとして扱う
        return $this->latestBookService->findRecentlyAdded($user, $limit);
    }
}
```

### 新ロジック：個人最適のレコメンドエンジン

```php
class PersonalizedRecommendationEngine implements RecommendationEngine
{
    public function recommendFor(User $user, int $limit = 20): array
    {
        // 新ロジック本体を書く
        $books = [];
        return $books;
    }
}
```

これで、

- 旧ロジック：`RecentBooksRecommendationEngine`  
- 新ロジック：`PersonalizedRecommendationEngine`  

という2つのクラスが、`RecommendationEngine` という同じインターフェースを実装している状態になりました。

## HomeController は「レコメンドできる何か」にだけ依存する

次に、`HomeController` を整理します。

やりたいことはシンプルで、「おすすめ本を返してくれる何か」にだけ依存するようにします。

```php
class HomeController
{
    public function __construct(
        private readonly RecommendationEngine $recommendationEngine,
    ) {}

    public function index(): Response
    {
        $user = auth()->user();

        $recommendedBooks = $this->recommendationEngine
            ->recommendFor($user, limit: 20);

        return view('home.index', [
            'recommendedBooks' => $recommendedBooks,
        ]);
    }
}
```

ここにはもう `FeatureToggle::enabled()` も `if` も出てきません。

「ホーム画面でおすすめ本を出す」というビジネスロジックはずっと固定。ただし、その裏で動いているエンジンが旧か新かは差し替え可能、という状態になっています。

## Feature Toggle は「どの実装を DI するか」にだけ使う

Feature Toggle を見るのは、**構成を決める場所だけ**にします。  
DI コンテナの設定などが典型です（以下はイメージコード）。

```php
// コンテナ設定のイメージ
if (FeatureToggle::enabled('new_recommendation')) {
    // 新しい個人最適レコメンドエンジンを使う
    $container->bind(RecommendationEngine::class, PersonalizedRecommendationEngine::class);
} else {
    // 旧ロジック（最近追加された本）を使う
    $container->bind(RecommendationEngine::class, RecentBooksRecommendationEngine::class);
}
```

これだけです。

アプリケーション本体のコードから見ると、いつでも `RecommendationEngine` ひとつに依存しているだけです。「その中身」が旧なのか新なのかは、コンテナ側で解決したものを引数にもらうだけになります。

## トグルを消すときは簡単に削除したい

最後に、旧ロジックとトグルを完全に捨てるフェーズです。

この設計にしておけば、やることはだいたい次の3つです。

1. DI コンテナの if 分岐を削除して、`RecommendationEngine` → `PersonalizedRecommendationEngine` を固定にする  
2. もう使わなくなった `RecentBooksRecommendationEngine` クラスを削除する  
3. トグル `new_recommendation` の定義と評価ロジックを削除する  

これで終わりです。
`HomeController` やその他のビジネスロジックには一切触らずにトグルを削除することができます。

## まとめ：Feature Toggle は「振る舞いのスイッチ」として扱う

読書管理アプリのおすすめ本レコメンドを例に、Feature Toggle の使い方を見直してみました。

ポイントをもう一度ざっくり並べると：

- アプリケーションコードの中で `if (FeatureToggle::enabled('...')) { ... }` を書くと、トグル削除時にビジネスロジックを書き換える必要が出てくる。トグルが散らばり、今の挙動を追いづらくなる。
- `RecommendationEngine` のような「振る舞い」のインターフェースを用意して旧ロジック／新ロジックを別クラスで実装し、Feature Toggle は「どの実装を DI するか」を決めるために使う。
- 段階的リリースはコンテナ設定や構成の変更だけで済むようになり、トグル削除時にもビジネスロジック側の変更は発生しなくなる。

Feature Toggle は具体的な処理で分岐をするのではなく、アプリケーションがどのように振る舞うのかを切り替えるために使いましょうという話でした。

今回の例はレコメンドのようなアルゴリズムだけでなく、
- 課金ロジック  
- 通知の配信戦略  
- 検索エンジンの実装  

みたいな、「中身を丸ごと差し替えたいところ」はだいたい同じパターンで整理できます。

トグルを「if を書くための道具」と考えるか、「振る舞いのスイッチ」と考えるかで、後からの片付けやすさがけっこう変わってきます。Feature Toggle を削除するところまで含めて開発だと考えると、最初の設計も慎重になれるはずです。

追加した Feature Toggle は開発が終わったらちゃんと捨てましょうね！